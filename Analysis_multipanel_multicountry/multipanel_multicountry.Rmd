---
title: "Multipanel multicountry comparison"
output:
  pdf_document: default
  word_document: default
  html_document: default
bibliography: ref.bib
csl: vancouver.csl  
---

# Introduction

The panels compared in this R markdown script include the GTseq panel (\texttt{GTseq}); the GTseq panel with CSP, TRAP, SERA2 and AMA1 removed (\texttt{GTseq\_notCTSA}); a panel using only CSP, TRAP, SERA2 and AMA1 (\texttt{onlyCTSA}); and a panel based on the Sanger barcode (\texttt{sanger\_barcode}). The marker and frequency data for \texttt{GTseq} and thus the data for panels derived from it (\texttt{GTseq\_notCTSA} and \texttt{onlyCTSA}) are attached as example data along with the **paneljudge** package. The Sanger barcode data used to generate the results plotted in this R markdown script were processed by \texttt{./Process\_Sanger\_Barcode.R}. The relatedness results based on all four panels mentioned above were generated by \texttt{./Generate\_results\_multipanel\_comparison.R}. 

The frequencies of the GTseq panel and its derivations are based on sample data collected in Colombia, French Guiana, Senegal and Mali. At present, the frequencies of the Sanger panel are based on sample data collected in Colombia, French Guiana and Senegal, but not Mali. Sample data are not included in this example analysis nor the distribution of the **paneljudge** package. 

There is substantial overlap (code and text) between this Rmd file and the paneljudge vignette, which is more pedagogical. To see the code, please consult \texttt{multipanel\_multicountry.Rmd}. 

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  echo = FALSE, 
  fig.width = 12, fig.height = 12, fig.fullwidth = TRUE, 
  fig.pos = 'H', 
  cache = TRUE, cache.comments = FALSE
)
```

```{r setup}
rm(list = ls())
require(RColorBrewer)
require(kableExtra)
library(paneljudge)
devtools::load_all() # Temporary hack

# Load sanger barcode data (external to paneljudge package)
load("markers_sanger_barcode.RData")
load("frequencies_sanger_barcode.RData")

# Load relatedness results generated by Generate_results_multipanel_comparison.R
load("mles_CIs_GTseq.RData")
load("mles_CIs_onlyCTSA.RData")
load("mles_CIs_GTseq_notCTSA.RData")
load("mles_CIs_sanger_barcode.RData")
```

```{r specify panels and their colours and countries and ks and rs and CTSA}
# Manually name panels and specify colours
panels <- c("GTseq","GTseq_notCTSA","sanger_barcode","onlyCTSA")

# Extract countries, ks and rs 
countries = names(mles_CIs_GTseq)
ks <- names(mles_CIs_GTseq$Colombia)
rs <- names(mles_CIs_GTseq$Colombia$`1`)

# Name s.t. when used with e.g. lapply returns named list
names(countries) <- countries 
names(ks) <- ks
names(rs) <- rs

# Single out CTSA from the GTseq panel
CTSA = markers$Amplicon_name[grepl("z", markers$Amplicon_name)]
CTSA_ind = which(markers$Amplicon_name %in% CTSA)

# Colours
cols_panels = RColorBrewer::brewer.pal(length(panels), 'Dark2')
names(cols_panels) <- panels
cols_countries <- RColorBrewer::brewer.pal(length(countries), 'Dark2')
names(cols_countries) <- countries
```

\pagebreak

# Comparative summaries and results

## Marker counts and positions

```{r marker count}
# GTseq panel
m <- nrow(markers) # Number of markers
num_chr <- length(unique(markers$chrom)) # Number of chromosomes
max_chr <- max(markers$chrom) # Max. number of chromosomes

# Sanger barcode panel
m_sb <- nrow(markers_sanger_barcode) # Number of markers
num_chr_sb <- length(unique(markers_sanger_barcode$chrom)) # Number of chromosomes
max_chr_sb <- max(markers_sanger_barcode$chrom) # Max. number of chromosomes
```

```{r panel overlaps}
# Overlap between GTseq and sanger barcode
sb_per_GTseq_amplicon <- apply(markers[,c("Start","Stop", "chrom")], 1, function(x){
  inds <- which(markers_sanger_barcode$pos %in% x[1]:x[2] & markers_sanger_barcode$chrom == x[3])
  markers_sanger_barcode$Amplicon_name[inds]
})

# Count number of sb markers per GTseq amplicon
sb_count_per_GTseq_amplicon <- sapply(sb_per_GTseq_amplicon, length)
# sb_per_GTseq_amplicon[CTSA] # No markers per CTSA
```

For relatedness inference, panels with many, evenly spaced and highly diverse markers are informative @taylor2019. The example panel based on GTseq has `r m` markers distributed across `r num_chr` of `r max_chr` chromosomes; the Sanger barcode panel has `r m_sb` markers distributed across `r num_chr_sb` of `r max_chr_sb` chromosomes:

```{r position plot, fig.height=6, fig.width=6}
# Amplicon position plot
par(mar = c(5.1,4.1,1,1))

# Null plot
plot(NULL, 
     xlim = range(markers$pos), 
     ylim = range(markers$chrom), las = 1, 
     ylab = 'Chromosome', xlab = 'Chromosomal position (base pair)')

# Positions based on GTseq
segments(x0 = markers$pos,
         x1 = markers$pos,
         y0 = markers$chrom + 0.15, 
         y1 = markers$chrom,
         lwd = 0.1)

# Positions based on sanger barcode
segments(x0 = markers_sanger_barcode$pos,
         x1 = markers_sanger_barcode$pos,
         y0 = markers_sanger_barcode$chrom - 0.15, 
         y1 = markers_sanger_barcode$chrom,
         col = cols_panels['sanger_barcode'], lwd = 0.1)

# Add asterisks below overlap
overlaps <- do.call(c, sb_per_GTseq_amplicon)
points(x = markers_sanger_barcode[overlaps, 'pos'], 
       y = markers_sanger_barcode[overlaps, "chrom"]-0.3, 
       pch = 0:3, lwd = 0.05, cex = 0.1, col = cols_panels['sanger_barcode'])

# Add chromosome lengths
for(chr in unique(markers$chrom)){
  segments(x0 = 0, x1 = chr_lengths[chr], y0 = chr, y1 = chr, lwd = 0.1) 
}

# Add CTSA annotations from GTseq panel
text(x = markers$pos[CTSA_ind], 
     y = markers$chrom[CTSA_ind], 
     labels = gsub('z', '', CTSA), 
     pos = 3, offset = 0.5, cex = 0.5)

text(x = max(markers$pos), y = 4, pos = 2, offset = 0.1, 
     labels = 'Marker positions are plotted using very fine lines
     because some are extremely close to one another.
     Zoom into the rendered pdf to tell them apart.')

# Legend 
legend('bottomright', inset = 0.01, bty = 'n', 
       legend = c("GTseq", "Sanger barcode"), 
       fill = c("#000000", cols_panels['sanger_barcode']))
```

Data on the GTseq panel are generated by sequencing amplicons spanning regions of the genome that highly diverse due to nearby single nucleotide polymorphisms (SNPs), which we call these regions microhaplotypes. These lengths are too small to perceive on the above plot of the microhaplotype marker positions, and some are very close together; see the paneljudge vignette for a summary of the distributions of region lengths and inter mid-point distances (minimum inter-region distance in the GTseq panel `r min(markers$distances)`).

Data on the Sanger barcode are generated by sequencing amplicons spanning regions containing individual SNPs [is that true?]. Some of the Sanger barcode SNPs are so close to one another (minimum inter-region distance in the Sanger barcode panel `r min(markers$distances)`) that they could be sequenced together as microhaplotypes versus individual SNPs. We do not have length information for the Sanger barcode [does it exist?]. However, GTseq regions contain `r paste(range(unique(sb_count_per_GTseq_amplicon)), collapse = ' to ')` Sanger markers, totaling `r sum(sb_count_per_GTseq_amplicon)` across all `r m` regions (they are marked below by a point whose symbol varies to facilitate distinction between markers that are extremely close to one another). Otherwise stated, there appears to be substantial overlap between \texttt{GTseq} and \texttt{sanger\_barcode}. Despite very close proximity to TRAP and AMA1, there are `r sum(sb_count_per_GTseq_amplicon[CTSA])` Sanger barcode markers within the CTSA regions of the GTseq panel. 

\pagebreak

## Marker diversities and effective cardinalities

Please see the vignette of the R package **paneljudge** for a summary of how to interpret diversities and effective cardinalities and the function documentation (accessed via e.g. `?compute_eff_cardinalities()`) for details on how they are computed. 

```{r compute diversities and effective cardinalities}
# Compute 
eff_cardinalities = sapply(frequencies, compute_eff_cardinalities)
eff_cardinalities_sb = sapply(frequencies_sanger_barcode, compute_eff_cardinalities)

# Extract diversities
diversities = sapply(frequencies, compute_diversities)
diversities_sb = sapply(frequencies_sanger_barcode, compute_diversities)
```

```{r summarise diversities}
kable(round(apply(diversities,2,summary),2), 
      caption = "Diversities GTseq") %>%
  kable_styling(latex_options = "hold_position")
kable(round(apply(diversities[-CTSA_ind,],2,summary),2), 
      caption = "Diversities GTseq without CTSA") %>%
  kable_styling(latex_options = "hold_position")
kable(round(apply(diversities[CTSA_ind,],2,summary),2), 
      caption = "Diversities CTSA only") %>%
  kable_styling(latex_options = "hold_position")
kable(round(apply(diversities_sb,2,summary),2), 
      caption = "Diversities Sanger Barcode") %>%
  kable_styling(latex_options = "hold_position")
```

\pagebreak

```{r summarise effective cardinalities}
kable(round(apply(eff_cardinalities,2,summary),2), 
      caption = "Effective cardinalities GTseq") %>%
  kable_styling(latex_options = "hold_position")
kable(round(apply(eff_cardinalities[-CTSA_ind,],2,summary),2), 
      caption = "Effective cardinalities GTseq without CTSA") %>%
  kable_styling(latex_options = "hold_position")
kable(round(apply(eff_cardinalities[CTSA_ind,],2,summary),2), 
      caption = "Effective cardinalities CTSA only") %>%
  kable_styling(latex_options = "hold_position")
kable(round(apply(eff_cardinalities_sb,2,summary),2), 
      caption = "Effective cardinalities Sanger Barcode") %>%
  kable_styling(latex_options = "hold_position")
```

\pagebreak 

```{r summarise top 4 markers per panel}
count <- 3

# GTseq
Top_eff_card <- apply(eff_cardinalities, 2, function(x) {
  list(round(head(sort(x, decreasing = T), count), 2))
})
Top_div <- apply(diversities, 2, function(x) {
  list(round(head(sort(x, decreasing = T), count), 2))
})
TopTab <- cbind(eff_cardinality = unlist(Top_eff_card), Diversity = unlist(Top_div))
kable(TopTab, caption = sprintf('Top %s per country GTseq', count)) %>%
  kable_styling(latex_options = "hold_position")

# GTseq not CTSA
Top_eff_card <- apply(eff_cardinalities[-CTSA_ind,], 2, function(x) {
  list(round(head(sort(x, decreasing = T), count), 2))
})
Top_div <- apply(diversities[-CTSA_ind,], 2, function(x) {
  list(round(head(sort(x, decreasing = T), count), 2))
})
TopTab <- cbind(eff_cardinality = unlist(Top_eff_card), Diversity = unlist(Top_div))
kable(TopTab, caption = sprintf('Top %s per country GTseq not CTSA', count)) %>%
  kable_styling(latex_options = "hold_position")

# Sanger barcode
Top_eff_card <- apply(eff_cardinalities_sb, 2, function(x) {
  list(round(head(sort(x, decreasing = T), count), 2))
})
Top_div <- apply(diversities_sb, 2, function(x) {
  list(round(head(sort(x, decreasing = T), count), 2))
})
TopTab <- cbind(eff_cardinality = unlist(Top_eff_card), Diversity = unlist(Top_div))
kable(TopTab, caption = sprintf('Top %s per country sanger barcode', count)) %>%
  kable_styling(latex_options = "hold_position")
```

```{r marker summary plots GTseq panel, fig.cap="Marker summaries (diversities and effective cardinalities) for the GTseq panel"}
par(mfrow = c(2,1))

# Effective cardinalities
matplot(log(eff_cardinalities), type = "b", pch = 20, 
        lty = 'solid', col = cols_countries[colnames(eff_cardinalities)], 
        xlab = "Marker index", 
        ylab = 'Log effective cardinality')

# Legend
legend('top', horiz = T, inset = -0.01, cex = 0.5, 
       bty = 'n', fill = cols_countries[colnames(eff_cardinalities)], 
       legend = colnames(eff_cardinalities))

# single out CTSA
abline(v = CTSA_ind, col = 'gray')
mtext(at = CTSA_ind, side = 3, text = gsub('z', '', CTSA), 
      las = 2, cex = 0.7, line = 0.25)

# Diversities
matplot(diversities, type = "b", pch = 20, 
        lty = 'solid', col = cols_countries[colnames(diversities)], 
        xlab = "Marker index", ylab = "Diversity")

# Legend
legend('top', horiz = T, inset = -0.01, cex = 0.5, 
       bty = 'n', fill = cols_countries[colnames(diversities)], 
       legend = colnames(diversities))

# single out CTSA
abline(v = CTSA_ind, col = 'gray')
mtext(at = CTSA_ind, side = 3, text = gsub('z', '', CTSA), 
      las = 2, cex = 0.7, line = 0.25)
```

```{r marker summary plots sanger barcode, fig.cap="Marker summaries (diversities and effective cardinalities) for the Sanger barcode"}
par(mfrow = c(2,1))

# Effective cardinalities
matplot(log(eff_cardinalities_sb), type = "b", pch = 20, 
        lty = 'solid', col = cols_countries[colnames(eff_cardinalities_sb)], 
        xlab = "Marker index", 
        ylab = 'Log effective cardinality')

# Legend
legend('top', horiz = T, inset = -0.01, cex = 0.5, 
       bty = 'n', 
       fill = cols_countries[colnames(eff_cardinalities_sb)], 
       legend = colnames(eff_cardinalities_sb))

# Diversities
matplot(diversities_sb, type = "b", pch = 20, 
        lty = 'solid', 
        col = cols_countries[colnames(diversities_sb)], 
        xlab = "Marker index", ylab = "Diversity")

# Legend
legend('top', horiz = T, inset = -0.01, cex = 0.5, 
       bty = 'n', 
       fill = cols_countries[colnames(diversities_sb)], 
       legend = colnames(diversities_sb))
```

```{r example plot of diversities wrt positions, fig.cap="Marker diversities and positions for the GTseq panel"}
# Null plot
plot(NULL, las = 1,
     bty = 'n', main = 'Diversity', 
     xlim = range(markers_sanger_barcode$pos), 
     ylim = range(markers_sanger_barcode$chrom)+c(-0.01,1.01), 
     ylab = 'Chromosome', 
     xlab = 'Chromosomal position (bp)')

# Add chromosome lengths
for(chr in unique(markers_sanger_barcode$chrom)){
  segments(x0 = 0, x1 = chr_lengths[chr], 
           y0 = chr, y1 = chr)  
}

for(chr in unique(markers_sanger_barcode$chrom)){
  
  chr_ind <- markers_sanger_barcode$chrom == chr
  markers <- markers_sanger_barcode$Amplicon_name[chr_ind]
  matplot(y = diversities_sb[markers,] + chr, 
          x = markers_sanger_barcode$pos[markers_sanger_barcode$chrom == chr], 
          type = "b", pch = 20, lty = 'solid', 
          col = cols_countries[colnames(diversities_sb)], add = T)
}
legend('bottomright', inset = 0.1, 
       legend = colnames(diversities_sb), 
       fill = cols_countries[colnames(diversities_sb)])
```

```{r}
total_eff_cardinality <- c(GTseq = sum(eff_cardinalities), 
                           GTseq_notCTSA = sum(eff_cardinalities[-CTSA_ind]), 
                           onlyCTSA = sum(eff_cardinalities[CTSA_ind]), 
                           sanger_barcode = sum(eff_cardinalities_sb))
```

\pagebreak

## Relatedness estimates and their CIs based on simulated data

```{r extract CI lengths}
# =======================================================
# Extract CI lengths and rhat per panel 
# =======================================================
CI_lengths_rhat <- list()

CI_lengths_rhat$GTseq <- lapply(mles_CIs_GTseq, function(mles_country){
  lapply(mles_country, function(mles_k){
    lapply(mles_k, function(mles_r){
      sapply(mles_r, function(mles_i){
        # Upper and lower 95% CIs (CI colnames diff for non-default CIs)
        CI_length <- mles_i['rhat', '97.5%'] - mles_i['rhat', '2.5%'] 
        rhat <- mles_i['rhat', 'krhat'] # relatedness estimate
        return(c('CIlength' = CI_length, 'rhat' = rhat)) # End of fun. 
      })
    })
  })
})

CI_lengths_rhat$GTseq_notCTSA <- lapply(mles_CIs_GTseq_notCTSA, function(mles_country){
  lapply(mles_country, function(mles_k){
    lapply(mles_k, function(mles_r){
      sapply(mles_r, function(mles_i){
        # Upper and lower 95% CIs (CI colnames diff for non-default CIs)
        CI_length <- mles_i['rhat', '97.5%'] - mles_i['rhat', '2.5%'] 
        rhat <- mles_i['rhat', 'krhat'] # relatedness estimate
        return(c('CIlength' = CI_length, 'rhat' = rhat)) # End of fun. 
      })
    })
  })
})

CI_lengths_rhat$onlyCTSA <- lapply(mles_CIs_onlyCTSA, function(mles_country){
  lapply(mles_country, function(mles_k){
    lapply(mles_k, function(mles_r){
      sapply(mles_r, function(mles_i){
        # Upper and lower 95% CIs (CI colnames diff for non-default CIs)
        CI_length <- mles_i['rhat', '97.5%'] - mles_i['rhat', '2.5%'] 
        rhat <- mles_i['rhat', 'krhat'] # relatedness estimate
        return(c('CIlength' = CI_length, 'rhat' = rhat)) # End of fun. 
      })
    })
  })
})

CI_lengths_rhat$sanger_barcode <- lapply(mles_CIs_sanger_barcode, function(mles_country){
  lapply(mles_country, function(mles_k){
    lapply(mles_k, function(mles_r){
      sapply(mles_r, function(mles_i){
        # Upper and lower 95% CIs (CI colnames diff for non-default CIs)
        CI_length <- mles_i['rhat', '97.5%'] - mles_i['rhat', '2.5%'] 
        rhat <- mles_i['rhat', 'krhat'] # relatedness estimate
        return(c('CIlength' = CI_length, 'rhat' = rhat)) # End of fun. 
      })
    })
  })
})
```

```{r extract RMSEs}
# =======================================================
# Extract RMSE results per panel 
# =======================================================
RMSE <- list()

RMSE$GTseq <- lapply(mles_CIs_GTseq, function(mles_country){
  lapply(mles_country, function(mles_k){
    rs <- names(mles_k) # Character vector
    names(rs) <- rs # name s.t. RMSE is named on return
    sapply(rs, function(r){
      mles_r <- mles_k[[r]]
      RMSE <- sqrt(mean(sapply(mles_r, function(mles_i){
        (mles_i['rhat', 'krhat'] - as.numeric(r))^2
      })))
      return(RMSE)
    })
  })
})

RMSE$GTseq_notCTSA <- lapply(mles_CIs_GTseq_notCTSA, function(mles_country){
  lapply(mles_country, function(mles_k){
    rs <- names(mles_k) # Character vector
    names(rs) <- rs # name s.t. RMSE is named on return
    sapply(rs, function(r){
      mles_r <- mles_k[[r]]
      RMSE <- sqrt(mean(sapply(mles_r, function(mles_i){
        (mles_i['rhat', 'krhat'] - as.numeric(r))^2
      })))
      return(RMSE)
    })
  })
})

RMSE$onlyCTSA <- lapply(mles_CIs_onlyCTSA, function(mles_country){
  lapply(mles_country, function(mles_k){
    rs <- names(mles_k) # Character vector
    names(rs) <- rs # name s.t. RMSE is named on return
    sapply(rs, function(r){
      mles_r <- mles_k[[r]]
      RMSE <- sqrt(mean(sapply(mles_r, function(mles_i){
        (mles_i['rhat', 'krhat'] - as.numeric(r))^2
      })))
      return(RMSE)
    })
  })
})

RMSE$sanger_barcode <- lapply(mles_CIs_sanger_barcode, function(mles_country){
  lapply(mles_country, function(mles_k){
    rs <- names(mles_k) # Character vector
    names(rs) <- rs # name s.t. RMSE is named on return
    sapply(rs, function(r){
      mles_r <- mles_k[[r]]
      RMSE <- sqrt(mean(sapply(mles_r, function(mles_i){
        (mles_i['rhat', 'krhat'] - as.numeric(r))^2
      })))
      return(RMSE)
    })
  })
})
```

```{r extract CIs for k10}
# =======================================================
# Extract CIs for k = 10
# =======================================================
CIs_k10 <- list()

CIs_k10$GTseq <- lapply(mles_CIs_GTseq, function(per_country){
  per_country[["10"]]
})

CIs_k10$GTseq_notCTSA <- lapply(mles_CIs_GTseq_notCTSA, function(per_country){
  per_country[["10"]]
})

CIs_k10$onlyCTSA <- lapply(mles_CIs_onlyCTSA, function(per_country){
  per_country[["10"]]
})

CIs_k10$sanger_barcode <- lapply(mles_CIs_sanger_barcode, function(per_country){
  per_country[["10"]]
})
```

```{r re-order by country}
# =======================================================
# Re order lists by country
# Entries for Mali sanger_barcode will be NULL as of April 2020
# =======================================================
CI_lengths_rhat <- lapply(countries, function(country){
  lapply(CI_lengths_rhat, function(per_panel){
    per_panel[[country]]
  })})

RMSE <- lapply(countries, function(country){
  lapply(RMSE, function(per_panel){
    per_panel[[country]]
  })})

CIs_k10 <- lapply(countries, function(country){
  lapply(CIs_k10, function(per_panel){
    per_panel[[country]]
  })
})
```

```{r plot CI length all k, echo = F}
par(mfrow = c(2,2))
for(country in countries){
  
  # Extract CI lengths and rhat for country
  per_country <- CI_lengths_rhat[[country]]
  
  # Extract range of CI lengths for null plot ylim
  CI_length_range <- range(sapply(per_country, function(per_panel){
    sapply(per_panel, function(per_k){
      sapply(per_k, function(per_r){
        per_r['CIlength',]
      }) 
    })
  }))
  
  # Null plot CI length versus r for any k with panel overlaid
  plot(NULL, ylim = CI_length_range, xlim = c(0,1), 
       main = country, 
       ylab = 'Length of 95% confidence interval', 
       xlab = expression(hat(italic(r))))
  mtext(side = 3, text = 'All simulated k values', line = 0, cex = 0.5)
  legend('bottom', inset = 0.01, legend = panels, pch = 20, col = cols_panels[panels], 
         cex = 0.5)
  
  for(panel in panels){
    
    Y <- sapply(per_country[[panel]],function(per_k){
      sapply(per_k, function(per_r){
        per_r['CIlength',]
      })})
    
    X <- sapply(per_country[[panel]],function(per_k){
      sapply(per_k, function(per_r){
        per_r['rhat',]
      })})
    
    # Plot CI length versus r for any k
    points(y = as.vector(Y),
           x = as.vector(X), 
           pch = 20, 
           col = adjustcolor(cols_panels[panel], alpha.f = '0.5'))
  }
}
```


```{r plot CI length per k, echo = F}
# =======================================================
# Plot CI lengths and rhat per country coloured by panel
# (for all k combined)
# =======================================================
par(mfrow = c(length(ks), length(countries)))

for(country in countries){
  
  # Extract countries
  per_country <- CI_lengths_rhat[[country]]
  
  # Re_organise s.t. k before panel
  per_country <- lapply(ks, function(k){
    lapply(per_country, function(per_panel){
      per_panel[[k]]
    })
  })
  
  for(k in ks){
    
    # Extract range of CI lengths for null plot ylim
    CI_length_range <- range(sapply(per_country[[k]], function(per_panel){
      sapply(per_panel, function(per_r){
        per_r['CIlength',]
      }) 
    }))
    
    # Null plot CI length versus r for any k with panel overlaid
    plot(NULL, ylim = CI_length_range, xlim = c(0,1), 
         main = country, 
         ylab = 'Length of 95% confidence interval', 
         xlab = expression(hat(italic(r))))
    mtext(side = 3, text = k, line = 0, cex = 0.5)
    legend('bottom', inset = 0.01, legend = panels, pch = 20, 
           col = cols_panels[panels], cex = 0.5)
    
    for(panel in panels){
      
      Y <- sapply(per_country[[k]][[panel]],function(per_r){
        per_r['CIlength',]
      })
      
      X <- sapply(per_country[[k]][[panel]], function(per_r){
        per_r['rhat',]
      })
      
      # Search for names using paste s.t. k=1 doesn't return k=10 etc. 
      ind <- which(grepl(paste(k, ''), names(Y)))
      
      # Plot CI length versus r for any k
      points(y = as.vector(Y),
             x = as.vector(X), 
             pch = 20, 
             col = adjustcolor(cols_panels[panel], alpha.f = '0.5'))
    }
  }}
```

```{r plot RMSE all ks, echo = F}
# =======================================================
# Plot RMSE against rhat per country coloured by panel
# (for all k combined)
# =======================================================
par(mfrow = c(2,2))

for(country in countries){
  
  # Extract CI lengths and rhat for country
  per_country <- RMSE[[country]]
  
  # Extract range of CI lengths for null plot ylim
  RMSE_range <- range(sapply(per_country, function(per_panel){
    sapply(per_panel, function(per_k){
      range(per_k)
    })
  }))
  
  
  # Null plot CI length versus r for any k with panel overlaid
  plot(NULL, ylim = RMSE_range, xlim = c(0,1), 
       main = country, 
       ylab = 'RMSE', 
       xlab = expression(hat(italic(r))))
  mtext(side = 3, text = 'All simulated k values', line = 0, cex = 0.5)
  legend('bottom', inset = 0.01, cex = 0.5, 
         legend = c(panels, paste('k =', ks )),
         pch = c(rep(NA, length(panels)), 1:length(ks)),
         lty = c(rep(1, length(panels)), rep(NA, length(ks))),
         col = c(cols_panels[panels], rep('#000000', length(ks))))
  
  for(panel in panels){
    
    per_panel <- per_country[[panel]]
    
    for(k in ks){
      # Plot CI length versus r for any k
      points(y = per_panel[[k]],
             x = as.numeric(names(per_panel[[k]])), 
             pch = which(ks == k), type = 'b', 
             col = adjustcolor(cols_panels[panel], alpha.f = '0.5'))
    }
  }
}
```

```{r plot RMSE lengths per k, echo = F}
# =======================================================
# Plot RMSE against rhat per country coloured by panel per k
# =======================================================
par(mfrow = c(length(ks),length(countries)))


for(country in countries){
  
  # Extract countries
  per_country <- RMSE[[country]]
  
  # Re_organise s.t. k before panel
  per_country <- lapply(ks, function(k){
    lapply(per_country, function(per_panel){
      per_panel[[k]]
    })
  })
  
  for(k in ks){
    
    # Extract range of CI lengths for null plot ylim
    RMSE_range <- range(unlist(per_country[[k]]))
    
    # Null plot CI length versus r for any k with panel overlaid
    plot(NULL, ylim = RMSE_range, xlim = c(0,1), 
         main = country, 
         ylab = 'RMSE', 
         xlab = expression(hat(italic(r))))
    mtext(side = 3, text = sprintf('k = %s', k), line = 0, cex = 0.5)
    legend('bottom', inset = 0.01, legend = panels, cex = 0.5, 
           lty = 'solid', col = cols_panels[panels])
    
    for(panel in panels){
      # Plot CI length versus r for any k
      points(y = per_country[[k]][[panel]],
             x = as.numeric(names(per_country[[k]][[panel]])), 
             pch = which(ks == k), type = 'b', 
             col = adjustcolor(cols_panels[panel], alpha.f = '0.5'))
      
    }
  }
}
```

```{r plot RMSE per panel, echo = F}
# Plot RMSE
par(mfrow = c(length(panels),length(countries)), mar = c(4,5,2,2), oma = rep(0,4), pty = 's')

for(country in countries){
  for(panel in panels){
    
    if(is.null(RMSE[[country]][[panel]])) {
      # Add null plot 
      plot(NULL, xlim = c(0,1), ylim = c(0,1), bty = 'n', xaxt = 'n', yaxt = 'n', ylab = '', xlab = '')
      
    } else {
      
      # Convert to matrix
      RMSEk_results <- sapply(RMSE[[country]][[panel]], function(x) x)
      
      rs = rownames(RMSEk_results)
      ks = colnames(RMSEk_results)
      
      # Interpolate panel colour and dark gray
      cols_ks = colorRampPalette(colors = c(cols_panels[panel],"#A9A9A9FF"))(length(ks))
      
      # Error in the r parameter
      matplot(RMSEk_results, type = 'b', pch = 20, lty = 1, col = cols_ks, panel.fist = grid(), 
              ylab = expression('RMSE: relatedness,'~italic(r)), 
              xlab = expression('Relatedness,'~italic(r)), 
              xaxt = 'n', bty = 'n', main = country)
      axis(side = 1, at = 1:length(rs), labels = rs)
      legend('bottom', bty = 'n', lty = 1, pch = 20, col = cols_ks, inset = 0.05, cex = 0.5, 
             legend = ks, title = expression('Switch rate parameter,'~italic(k)))
      mtext(text = panel, line = -1, cex = 0.5)
    }
  }
}
```

```{r plot CIs, echo = F, fig.height=11, fig.width=11}
par(mfrow = c(length(countries),length(rs)), 
    mar = c(0,0,0,0), oma = c(4,4,2,2), 
    family = 'serif', pty = 'm')

for(country in countries){
  for(r in rs){
    for(panel in rev(panels)){
      
      # Extract results
      per_i = CIs_k10[[country]][[panel]][[r]]
      if (is.null(per_i)) next()
      
      restCIs = sapply(per_i, function(per_i) per_i['rhat',]) # Extract results for r
      
      # Order results
      Order = sort.int(restCIs['krhat',], index.return = T)$ix
      ADD = ifelse(country == countries[1], FALSE, TRUE)
      nrep <- ncol(restCIs)
      
      # Null plot 
      if(panel == rev(panels)[1]) {
        plot(NULL, pch = 20, ylim = c(0,1), xlim = c(1,nrep), 
             xaxt = 'n', yaxt = 'n', panel.first = grid())
      }
      
      # Plot results
      polygon(x = c(1:nrep, nrep:1), 
              y = c(restCIs['2.5%', Order], rev(restCIs['97.5%', Order])),
              col = cols_panels[panel], border = NA)
      points(restCIs['krhat',Order], col = 'white', pch = 20, cex = 0.5)
      
      # Data-generating r
      abline(h = as.numeric(r), col = 'black')
      
      # Add title
      if(r == rs[1]){
        axis(side = 2, las = 1)
        title(main = country, line = -6)
      }
      
      # Add x-axis
      if(country == tail(countries, 1)){
        axis(side = 1, las = 1)
        title(xlab = 'Sample pair index')
      }
      
    } 
  }
}

# Add country legend: 
legend('bottom', bty = 'n', legend = panels,
       fill = cols_panels, inset = 0.01)
legend('bottom', bty = 'n', legend = expression("data-generating"~italic(r)),
       lty = 1, inset = 0.25)
title(xlab = expression("Simulated sample pair index per data-generating"~italic(r)), 
      ylab = 'Relatedness', outer = T, cex = 1.5)
```

Based on the marker count multiplied by the mean effective cardinality (i.e. the effective cardinality summed over all markers), we can get a rough idea of how confidence intervals around relatedness estimates might scale, e.g. from large (least informative) to smaller (more informative), the panels considered here are ordered as follows: `r names(sort(total_eff_cardinality))`. 

# References
